# Partners
* Keilani Caruso kcaruso4
* Kevin Sherman ksherma6

# How to run the Driver
The driver will be able to run so long as a json file is supplied. Optionally, if a user would like to specify the number of nodes running they should enter the number of nodes (integer value) and then the file to read transactions from. 

# How to run the Generator
Similar to the driver file, the generator file will run with either no additional parameters or two. If no parameters are supplied on the command line then the default number of transactions is 15 (excluding the first transaction) and the default number of signers is 8. If a user would like to change these values they should specify the number of transactions (integer) and then the number of signers (int). 

# How to test
To generate a relatively acceptable file make sure that the only uncommented code in the for loop starting at line 235 is under the comment "Normal Run". We have found that occasionally the createValidTx method will not produce a proper transaction because of the randomness of the method. To generate a file with some invalid transactions comment out all of the code under the "Normal Run" and uncomment the code under the "For Testing Run" comment. You can alter the parameter to create an invalid transaction by changing the if statement. To specify the type of invalid transaction you would like please uncomment out the specific methods that apply to the desired edge case. For our submitted json file we decided to include a transaction with an invalid number, an invalid input output match-up, and a double spending. 

# Dishonest Node
We added a dishonest node to our driver program. We specified on line 174 of the Driver file that if this is the last thread we are creating, then set the node to be dishonest. In our program, dishonest nodes never validate a broadcasted block or transaction read from a pool. If the node recieves a block, it automatically broadcasts it, and if the node reads a transaction it creates an invalid block and broadcasts it (has arbitrary prev, pow, and nonce values). Because of this and how our node class is written, we expect that the blockchain file generated by this node at the end of the run differs from the rest of the other generated files. 

# How we handled forking
Forking is handled in our Node file where the main portion of handling is done between lines 238 and 267 in the verify method. This method handles verifying broadcasted blocks. In order to handle forking we decided to create a map where the key is the head block of a given fork and the value is a list of blocks in the given fork. When a broadcast is recieved and validated, we then check to see if it should be added to the current chain we are working on. If it is, then we update map and locally saved blockchain head and continue. If this block is not added to our current working chain, we then iterate through the map to find the fork it is to be added to. We only add a block to a fork or create a new fork if the block that the broadcast points to is either the head of the fork or the next block in. We chose to do this becuase if the longest chain has a 2 block lead even after adding this broadcast, then there is no sense in maintaining the fork. When a block is added to a fork and the list of this given fork is either the same length or greater than the length of the fork the node is working on, then the node broadcasts it. If this broadcasted block makes a different fork the new longest chain, we then update the pointer the node is working on. 
